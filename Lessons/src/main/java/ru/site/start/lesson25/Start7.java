package ru.site.start.lesson25;

public class Start7 {
}

// Тесты


// Задание 1
// Каков будет результат компиляции и запуска данного кода?

//class Test1 implements interface1, interface2{
//    public void abc() { System.out.println("OK"); }
//    public static void main(String[] args){
//        Test1 t = new Test1();
//        ((interface1)t).abc(); // Метод abc принадлежит переменной t, а она типу Test1. Затем Test1 кастим до интерфейса. Затем во время ран тайм баиндин происходит переопределение метода (используется класс Test1, где new ...) и выводится саут ОК.
////        t.abc(); // Можно как с кастин (как сверху), так и без (как на этой строке)
//    }
//}
//interface interface1{
//    int a = 5;
//    void abc();
//}
//interface interface2{
//    int a = 10;
//    void abc();
//}

// Результат вывода: ОК
// Метод abc с интерфейса 1 и 2 переопределен в Test1. Но потом через кастин указывается какой именно интерфейс брать, где абстрактный метод.
// Чтобы вывести переменную, нужно в саут помещать interface1.a или interface2.a. Название интерфейса + переменная. Переменная не видна, в отличии от метода, если также ее вызывать как метод.
// Чтобы вывести переменную также можно написать так: System.out.println(((interface2)t).a); - веди себя как переменная типа интерфейс 2.





// Задание 2
// Рассмотрите данный код:

//class Employee { void sleep() { System.out.println("Employee sleeps"); } }
//class Doctor extends Employee { void sleep() { System.out.println("Doctor sleeps"); } }
//
//class Test2 {
//    public static void main(String [] args) {
//        Employee e = new Employee();
//// some code
//        e.sleep();
//        x.sleep();
//    }
//}

//     Какие выражения (по отдельности) могут быть написаны на строке //some code чтобы на экран выводилось:
//        Employee sleeps
//        Doctor sleeps

// Варианты:
//        A) Employee x = new Employee();
//        B) Employee x = new Doctor();
//        C) Doctor x = new Doctor();
//        D) Doctor x = new Employee();
//        E) Employee x = (Doctor)new Employee();
//        F) Doctor x = (Doctor)new Employee();

// Объяснение вариантов и указание какие варианты подходят
// А - не подходит, так как у нас уже есть такой вариант. Будет два раза одно и то же выводиться, плюс второе сообщение не получится вывести, так как переменная х будет занята.
// B - подходит
// C - подходит
// D - так писать нельзя.
// E - если так написать, то не будет компиляционной ошибки, но во время ран тайм баиндин будет иксепшин (нельзя так кастить). Выяснится, что это не доктор, а какой-то работник.
// F - если так написать, то не будет компиляционной ошибки, но во время ран тайм баиндин будет иксепшин (нельзя так кастить). Выяснится, что это не доктор, а какой-то работник.




// Задание 3
// Каков будет результат компиляции и запуска данного кода?

class Animal {
}
class Mouse extends Animal {
    void abc() {
        def(new Animal(), new Mouse());
        def((Mouse) new Animal(), new Mouse());
    }
    void def(Animal a1, Mouse m1) {
        Mouse m2 = (Mouse) a1;
        Animal a2 = (Animal) m1;
    }
    public static void main(String[] args) {
        new Mouse().abc();
    }
}

// Результат:
/**
 * Компиляционных ошибок нет, но во время ран тайм баиндин будет иксепшин. Нельзя закастить класс.
 * Также если каст поправить, далее могут быть другие ошибки.
 *
 * Как работает программа:
 * 1. В мэин создаем объект маус и вызываем метод abc.
 * 2. Смотрим что делает метод abc. Метод abc вызывает два раза метод def.
 * 3. Метод def принимает два параметра - два разных объекта. Вставляется первый объект в первый параметр,
 * тоже самое и для второго параметра - вставляется второй объект. Типы подошли.
 * Внутри метода def в его теле:
 * a1 - это Animal. Animal может кастится до Mouse? Да, так как есть связь is-a.
 * Но new Animal() - это объект класса Animal. Это не переменная Animal, которая ссылается на Mouse.
 * Поэтому ран тайм баиндин будет иксепшин - кастовать так нельзя.
 * Далее если смотреть код:
 * Animal a2 = (Animal) m1;
 * m1 - это new Mouse(). new Mouse() можно кастить до Animal? Да.
 * Также на этой строке Animal a2 = (Animal) m1; можно не писать кастин, так как он автоматически сделается.
 * Так как любой Mouse - это Animal.
 * Далее идет разбор строки def((Mouse) new Animal(), new Mouse());
 * (Mouse) new Animal() - пытаемся кастить объект Animal до Mouse. Но этот объект не является Mouse.
 * Кэмпаил тайм - это пройдет, но во время ран тайм будет иксепшин.
 * Второй параметр new Mouse() - он уже ранее в объяснения объяснялся. Также будет работать, как
 * при вызове первого метода def. def(new Animal(), new Mouse());
 */
