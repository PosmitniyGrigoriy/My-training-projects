package ru.site.start.lesson35;

public class Start1 {
}

// Задание 1
// Что будет результатом компиляции и запуска данного кода?

//class B extends A {
//
//    public int a = 20;
//
//    public void abc() {
//        System.out.println("child non-static");
//    }
//
//    public static void abc2() {
//        System.out.println("child static");
//    }
//
//    public static void main(String[] args) {
//        B b = new B();
//        System.out.println(b.a);
//        System.out.println(((A) b).a);
//        b.abc();
//        ((A) b).abc();
//        b.abc2();
//        ((A) b).abc2();
//    }
//
//}
//
//class A {
//
//    public int a = 10;
//
//    public void abc() {
//        System.out.println("base non-static");
//    }
//
//    public static void abc2() {
//        System.out.println("base static");
//    }
//
//}

// Результат вывода:

// 20
// 10
// child non-static
// child non-static
// child static
// base static

// Объяснение к коду:
    /**
     * Есть класс А. Он имеет переменную, обычный метод и статический метод.
     * Есть класс Б. Он наследует класс А. Хайдит переменную класса А, переопределяет метод abc и
     * хайдит статический метод из класса А.
     * Далее создается объект Б, на которую ссылается переменная Б.
     * Так как при создании объекта указан тип Б (до равно), то вызовится в первом сауте переменная а из класса Б.
     * Затем во втором сауте выводит тоже переменную А от объекта Б (переменная),
     * но указываем тип А (кастим до класса А). Кастить можно. Потому что Б - это всегда А.
     * Так как указан сейчас через кастинг класс А, то переменная А вызовится у класса А (10, а не 20).
     * Выше объяснения - это для вывода первых двух саутов (20 и 10).
     *
     * Дальше идет b.abc(); Ран там происходит проверка. В на что ссылается? На объект класса В.
     * Вызывается метод этого класса, выведется child non-static.
     *
     * Дальше идет ((A) b).abc(); Хоть кастинг нормально проходит, и переменная b стала относится
     * к классу А, но вызов метода abc() происходит ран тайм, и происходит проверка. Переменная b на самом деле
     * ссылается на какой объект? На объект B. Тогда вызовится метод abc() класса В.
     * Поэтому выведется System.out.println("child non-static");
     *
     * Затем идет b.abc2(); Вызов метода abc2() происходит кэмпаил тайм, потому что это стэтик метод.
     * Переменная b относится к классу В, поэтому метод выводит System.out.println("child static");
     *
     * Далее идет ((A) b).abc2(); Здесь тоже самое происходит, только кастим до класса А. Из-за того что
     * кэмпаил тайм определяет какой статический метод будет вызыван из класса А или из класса В,
     * а здесь мы говорим b пускай чувствует себя как А, компилятор воспринимает эту ссылочную переменную
     * b как тип А, поэтому будет вызываться статэк метод abc2() из класса А. Появится на экране
     * System.out.println("base static");
     */
