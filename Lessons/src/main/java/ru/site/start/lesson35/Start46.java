package ru.site.start.lesson35;

public class Start46 {
}

// Задание 46
// Что будет результатом компиляции и запуска данного кода?

//class Test {
//
//    static String s = "";
//
//    public static void main(String[] args) {
//        int[] array = {1, 2, 5, 8};
//        for (int a : array) {
//            for (int j = 0; j < 4; j++) {
//                if (a > 1.5 && a < 6) {
//                    continue;
//                }
//                System.out.println(a);
//                if (j == 1)
//                    break;
//                continue;
//            }
//            continue;
//        }
//    }
//
//}

// Результат вывода:

// 1
// 1
// 8
// 8

// Объяснение к коду:
/**
 * Вначале s пустая. В одномерном массиве лежит 4 значения: 1, 2, 5, 8. Они по очереди поступают в фор ич.
 * Первое значение: a = 1.
 * j = 0. 0 < 4? Да. 1 > 1,5? Нет. Тогда пропускает тело первого иф. Выводим на экран 1. j(0) = 1? Нет. Тогда пропускает тело второго иф и делаем кэнтинию.
 * j = 1. 1 < 4? Да. 1 > 1,5? Нет. Тогда пропускает тело первого иф. Выводим на экран 1. j(1) = 1? Да. Заходим в тело второго иф, а там брэйк. Выходим из цикла фор (второго) и переходим к следующему числу (2).
 * Второе значение: а = 2.
 * j = 0. 0 < 4? Да. 2 > 1,5? Да. 2 < 6? Да. Кэнтинию.
 * j = 1. 1 < 4? Да. 2 > 1,5? Да. 2 < 6? Да. Кэнтинию.
 * j = 2. 2 < 4? Да. 2 > 1,5? Да. 2 < 6? Да. Кэнтинию.
 * j = 3. 3 < 4? Да. 2 > 1,5? Да. 2 < 6? Да. Кэнтинию. Выход из внутреннего фор. Возвращается на первый фор и берет новое значение.
 * Третье значение: а = 5.
 * j = 0. 0 < 4? Да. 5 > 1,5? Да. 5 < 6? Да. Кэнтинию.
 * j = 1. 1 < 4? Да. 5 > 1,5? Да. 5 < 6? Да. Кэнтинию.
 * j = 2. 2 < 4? Да. 5 > 1,5? Да. 5 < 6? Да. Кэнтинию.
 * j = 3. 3 < 4? Да. 5 > 1,5? Да. 5 < 6? Да. Кэнтинию. Выход из внутреннего фор. Возвращается на первый фор и берет новое значение.
 * Четвертое значение: а = 8.
 * j = 0. 0 < 4? Да. 8 > 1,5? Да. 8 < 6? Нет. Тогда пропускает тело первого иф. Выводим на экран 8. j(0) = 1? Нет. Тогда пропускает тело второго иф и делаем кэнтинию.
 * j = 1. 1 < 4? Да. 8 > 1,5? Да. 8 < 6? Нет. Тогда пропускает тело первого иф. Выводим на экран 8. j(1) = 1? Да. Заходим в тело второго иф, а там брэйк. Выходим из цикла фор (второго) и переходим к первому фор. Так как там значения закончились, то заканчивается работа программы.
 *
 * Итого вывод:
 * 1
 * 1
 * 8
 * 8
 */