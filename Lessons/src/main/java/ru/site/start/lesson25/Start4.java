package ru.site.start.lesson25;

import java.util.HashMap;
import java.util.Map;

public class Start4 {
}

/**
 * Кастин:
 *
 * Reference data types casting
 *
 * Кастин - это процесс, когда мы заставляем переменнюуо дного типа данных вести себя как переменную другого типа данных.
 *
 * Кастинг возможет только тогда, когда между классами/интерфейсами существует is-a взаимоотношение.
 * Делая кастинг, мы не меняем тип данных объекта, а заставляем его чувствовать себя как объект другого типа.
 *
 * Пример ниже в сауте.
 */

class q3 {
    public static void main(String[] args) {
        Employee52 emp1 = new Teacher52();
        Employee52 emp2 = new Driver52();
        Employee52 emp3 = new Doctor52();

        // Снизу строка саута. Там будет компиляционная ошибка, так как переменной emp3 принадлежит объекту Doctor52, а этот класс наслудуется от Employee55, поэтому и ошибка компиляции, так как класс q3 не имеет связи с Doctor 52 is a.
//        System.out.println(((q3)emp3).specialization); // Ошибка компиляции

        // Первый способ кастин:
//        Doctor52 d1 = emp3; // Ошибка компиляции, так как не каждый работник является доктором.
        Doctor52 d2 = (Doctor52)emp3; // переменная emp3 (работник) прокастина до доктора. И тогда через переменную d2 можно в сауте вызывать переменную специализация.
        // Кастинг преобразует переменную под другой тип. Был тип рабочий. Стал тип доктор.
        System.out.println(d2.specialization);

        // Второй способ кастин:
//        System.out.println(emp3.specialization); // Объяснение этой строки ниже
        /**
         * Выше в сауте указана переменная специализация. Она есть у класса доктор.
         * А у нас тип рабочий. В классе рабочего нет переменной специализация, поэтому эту переменную
         * нельзя вызывать. Но, если ее закастить. У нас есть объект доктор и тип рабочий
         * переменная есть у доктора. поэтому можно закастить и будет работать. Пример каста ниже.
         */
        System.out.println(((Doctor52)emp3).specialization); // Перед переменной emp3 дописать (Doctor) - в скобках, затем еще скобки дописать. Получится ((Doctor52)emp3). Такой кастинг будет работать и переменную получится вызывать.
// Выше саут. В параметрах это: ((Doctor52)emp3).specialization . Переменую или метод нужно вызывать не на (Doctor52)emp3. , а на ((Doctor52)emp3). . Это как объект (последний вариант) и на объект вызываем переменную или метод. А если до этого как было написано (Doctor52)emp3. , то это не понятное что-то для компилятора, поэтому он не найдет переменную и метод, так как нет скобок дополнительных.

        // В начале кода есть строка Employee52 emp2 = new Driver52();
        // Далее будет работа с этой строкой
        System.out.println(((Doctor52)emp2).specialization); // Хоть на этой строке нет компиляционной ошибки, но при ран тайм баиндин будет ошибка (иксепшин). Не получилось закастить. Переменная специализация есть у класса доктор, а здесь вызывается водитель. У него нет переменной этой. И когда идет кастин, то во время ран тайм баиндин будет проверка и не окажется этой переменной (специализация) у водителя, поэтому и иксепшин будет.

        /**Когда может быть полезен кастин:
         * Если у нас тип основной класс (до равно) а после равно саб-класс.
         * В саб классе 20 методов. А в основной классе (типе) 5 методов.
         * Доступны для работы будут 5 методов.
         * Чтобы работать с оставшимися 15 методоами нужно создавать новый объект,
         * но тип указать тот же класс, что и объект создается.
         * или можно закастить, чтобы не создавать второй раз объект.
         * взять переменную и до нее дописать кастин, тогда можно будет вызывать оставшиеся 15 методов.
         */
    }
}

class Employee52 implements TTT {
    int salary = 100;
    String name = "Alex";
    int age;
    int experience;
    public void work() { System.out.println("Рабочий"); }
    public void help() { System.out.println("111"); }
}

class Teacher52 extends Employee52 {
    int kolichestvoUchenikov;
    public void uchit() { System.out.println("Учитель"); }
}

class Driver52 extends Employee52 {
    String nameCar = "Тойота";
    public void vodit() { System.out.println("Водитель"); }
}

class Doctor52 extends Employee52 {
    String specialization = "Хирург";
    public void lechit() { System.out.println("Доктор"); }
}

interface TTT {
    void help();
}

/**
 * Кастин из саб класса в супер класс происходит автоматически. Это называют ап кастинг (Upcasting).
 * Доктор повышается до работника.
 * Пример: Employee employee = new Doctor();
 * Получается переменную рабочий типа рабочего ссылаем на объект доктор. Получается доктор будет себя чувствовать как рабочий.
 *
 * Далее.
 * Когда делается обратно. Это дан кастин (Downcasting).
 * Рабочий понижается до водителя.
 * Doctor d2 = (Doctor)employee;
 *
 * Если между классами/интерфейсами нет is-a отношения, то компилятор не допустит casting. Даже если компилятор
 * допустил casting, то во время ран тайм байиндин появится иксепшин, если объект, который
 * мы делаем cast на самом деле не принадлежит классу, на который мы его делаем cast.
 */

// Ниже будет тема сравнения объектов

class q33{
    public static void main(String[] args) {
        q33 q33 = new q33();
        TTT ttt = new Employee52();
        Employee52 emp = new Employee52();
        Employee52 emp1 = new Teacher52();
        Employee52 emp2 = new Driver52();
        Employee52 emp3 = new Doctor52();

        System.out.println(emp == emp1); // false. emp и emp1 могут ссылаться на один объект. В данном случае на объект Teacher52.
        System.out.println(emp == emp2); // false
        System.out.println(emp == emp3); // false
        System.out.println(emp == ttt); // false
//        System.out.println(emp == q33); // Будет компиляционная ошибка. Нельзя сравнить два разных класса через ==. Объекты нельзя сравнивать через ==, так как у них нет отношения is a.
        System.out.println(emp.equals(q33)); // А так сравнивать можно объекты (как разные объекты - разных классов, так объекты одного класса). Так как используется иквелс.
        System.out.println("--------");
        System.out.println(emp1 == emp); // false
        System.out.println(emp1 == emp2); // false
        System.out.println(emp1 == emp3); // false

        System.out.println("--------");

        // Созданные объекты сверху положены в массив на строке ниже
        Employee52[] array52 = {emp, emp1, emp2, emp3};
        // Далее нужно пройтись по каждому объекту через фор ич, найти водителя и только с ним работать. Можно вызывать какой-то метод или переменную. Это нужно сделать, используя оператор instanceof, сравнивая.
        for(Employee52 emp52 : array52) {
            if(emp52 instanceof Driver52) { // instanceof оберегает от ран тайм иксепшина, так как выдает только объект водитель. а уже в теле условия делаем что-то с найденным объектом водитель
                System.out.println(((Driver52) emp52).nameCar); // Если instanceof нашел объект водитель, то на этой строке, где саут, делаем кастин и тогда будет правильно работать. Если кастин не делать, то переменные и методы водителя не будут найдены, так как мы идем от Employee, а там нет переменных и методов водителя. Поэтому кастинг нужно делать, чтобы появились переменные и методы водителя.
            }
        }

    }
}