package ru.site.start.lesson25;

public class Start6 {
}

/**
 * Кастин примитивных типов данных
 *
 * В данной теме не используются термины Upcasting и Downcasting.
 * Здесь термины -
 *
 *
 * 19 форм расширения (widening):
 *
 * Из меньшего типа данных переходит в больший тип данных.
 * byte   =>   short, int, long, float, double
 * short  =>   int, long, flot, double
 * char   =>   int, long, float, double
 * int    =>   long, float, double
 * long   =>   float, double
 * float  =>   double
 */

class T10 {
    public static void main(String[] args) {
        byte b = 10;
        int a = b;
//        Байт положен в инт. Теперь значение b будет в большее широком типе данных переменной a.
    }
}

/**
 * Narrowing (сужение) without casting происходит, если выполняются 3 условия:
 *
 * 1. Если int кастится в byte, short, char.
 * 2. Если значение int - это константа.
 * 3. Если значение int помещается в соответствующий тип данных. указано какое-то значение (оно в инт, так как инт по умолчанию). если это значение умещается в диапазон типа какого-то (байт, шорт, чар и так далее), то положить можно без кастин.
 *
 * Есть 2 варианта сужения: без кастин (3 пункта выше) и с кастин.
 */

// Пример сужения без кастин
class T11 {
    public static void main(String[] args) {
        System.out.println(7); // Значение 7 положено в int, так как int по умолчанию устанавливается.
        byte b2 = 3;
        short s1 = -6;
        char c1 = 100;
        // Выше 3 строки. Интовые значения ложатся в byte, short, char. Как сказано выше в трех пунктах. Там пункт 1. Пункты 2 и 3 походу не подходят суда. Но подходят ниже в примерах.
        // Значение более широково типа данных присваивается менее широкому типу данных
        // Каст в данном случае делать не нужно.
        // 3, -6, 100 - это константы.
        // А не константы - ниже 2 строки
        int i1 = 3;
//        short s2 = i1; // На этой строке будет компиляционная ошибка, так как инт пробуется положить в более узкий тип шорт. Нужно делать каст. Тогда ошибка пропадет. Пример ниже.
        short s2 = (short) i1;
        // или так можно сделать. добавить final, тогда 3 будет константа и можно без кастин сделать
        final int i11 = 3;
        short s22 = i11;

        // Для long другая ситуация
        long l12 = 1; // если дописать final, как в примере выше, то там ошибка пропала, а в long останется. Здесь только кастин поможет
//        int i12 = l12; // Ошибка компиляции. Нужно кастовать.
        int i12 = (int)l12;
    }
}

/**
 * 22 формы сужения (narrowing):
 * short   =>   byte, char
 * char    =>   byte, short
 * int     =>   byte, short, char
 * long    =>   byte, short, char, int
 * float   =>   byte, short, char, int, long
 * double  =>   byte, short, char, int, long, float
 */

class T12 {
    public static void main(String[] args) {
        int i20 = 111111;
        short s20 = (short)i20;
        System.out.println(s20); // -19961. Шорт может быть до 32К вроде. Без каста не получится запустить. А с ним можно исправить компиляционную ошибку, но считает не так как нужно. потому что не влазиет значение в диапазон инт в шорт. часть информации теряется.
        // Как именно считается число для вывода - не нужно знать для экзамена. это к строке выше и к строке ниже (там уже char).

        char c10 = (char)-8;
        System.out.println(c10); // Выведется ?
        // Что произошло: значение инт (-8) закастили в чар и вывелся символ.

        /**
         * Кастить можно типы, которые соответствуют друг другу.
         * Нельзя закастить булиэн в инт.
         */

        int i12 = (int)3.14;
        System.out.println(i12); // Вывелось: 3. А после запятой не вывелось, так как инт это не поддерживает.

        double d = 75465628.47461;
        byte b1 = (byte)d;
        System.out.println(b1); // -100. Не вместилось значение дабл в байт. Часть данных потеряна.

        int i = 2147483647;
        System.out.println(i + 1); // Вывелось: -2147483648.
        System.out.println(i + 2); // Вывелось: -2147483647.
        System.out.println(i + 3); // Вывелось: -2147483646.
        /**
         * Когда к максимальному значению инт прибавляется единица, то места уже нет. И возвращается к максимальному минусовому значению -2147483648.
         * Если будет еще +1, то максимальное значение минусовое станет меньше на 1 и так оно идет к максимальному положительному значению.
         * По кругу идет. Бесконечно.
         */

        /**
         * Numeric promotion - это конвертация меньшего численного типа данных в больших.
         *
         * Numeric promotion происходит в следующих случаях:
         * 1. Если имеются 2 разных значения (разных типов данных), джава автоматически конвертирует меньший числовой тип данных в больший.
         * Пример ниже.
         */

        int i4 = 5;
        long l4 = 10;
        System.out.println(i4 + l4); // Сначала инт конвертируется в лонг, затем логн складывается с лонгом и выводится 15.

//        int result = i4 * l4; // Без кастин компиляционная ошибка. Инт конвертируется в лонг. Потом лонг умножается на лонг и ложится в инт. Нельзя положить лонг в инт. Поэтому кастить. Пример ниже.
        int result = (int)(i4 * l4);
        System.out.println(result); // 50

        i4 *= l4; // Здесь автоматический кастин сработает. Кастить самому не нужно.
        System.out.println(i4); // 50

        /**
         * 2. Если одно из значений - это целочисленное число, а другое дробное, то джава автоматически конвертирует целочисленный тип анных в дробный.
         * Пример ниже.
         */

        // Дабл больше чем лонг. Дабл - самый большой по вместимости.

        int i5 = 5;
        float f5 = 10.144f;
        System.out.println(i5 + f5); // 15.144. инт конвертируется во флоат, флоат + флота и выводится итоговое число.

        /**
         * 3. Если значение типов данных byte, short, char участвуют в арифметических операциях,
         * то они перед этим конвертируются в тип данных int, даже если в данных арифметических
         * операциях значение типа данных int не участвует. Исключение: унарные операторы.
         * Использование ++ к типу данных byte не конвертирует результат оператора в int.
         * Пример ниже.
         */

        int b = 3;
        short s = 4;
        char c = 5;
        System.out.println(b + s + c); // 12. Все три переменные конвертируются в инт, затем они складываются (уже в инте) и выводится результат
        short s2 = s++; // Унарные операторы (++) не конвертируются в инт. Сохраняют свой тип данных.

        /**
         * 4. После применения вышеуказанных трех правил, когда все операнды стали одного типа данных,
         * результирующее значение, которое получается после срабатывания всех операторов будет
         * такого же типа данных, что и тип данных операнд.
         *
         * То, что выше было. Был инт и флоат. Инт стал флоат. Флоат + флоат. и сохранится должно во флоат.
         */

        byte b10 = 10;
        float f10 = 7;
        double d10 = 2.0;
        double result10 = b10 + f10 - d10;
        System.out.println(result10);
        // Сначала идет байт плюс флоат. байт конвертируется во флоат, затем два значения складываются.
        // Затем идет итоговое значение флоат минус дабл. флоат конвертируется в дабл, затем первое значение вычитает второе.
        // Результат нужно сохранить в дабл, иначе будет компиляционная ошибка.

        double d20 = 3.14;
        float f20 = 6.28f;
        // Если складывать дабл и флоат, то флоат конвертируется в дабл, затем дабл складывается с дабл и результат выводится в дабл (результат нужно сохранять в переменную типа дабл).


        // Ниже другая тема. Как можно объявлять переменные.
        int a33, b33 = 3, c33, d33 = b33+5; // Так можно писать. Перечислить все переменные одного типа через запятую, а где нужно, то еще инициализировать. Инициализация идет только к одной переменной, а не ко всем.

    }
}